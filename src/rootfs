#!/bin/bash

# mount chroot path
# $1: target path
mount_chroot() {
    local target=$1
    if [ -z "$target" ]; then
        log_info "usage: mount_chroot <target>"
        return -1
    fi
    $SUPERUSER_PERMISSION grep -q $target/proc /proc/mounts && return
    $SUPERUSER_PERMISSION mount -t proc chproc $target/proc
    $SUPERUSER_PERMISSION mount -t sysfs chsys $target/sys
    $SUPERUSER_PERMISSION mount -t devtmpfs chdev $target/dev || mount --bind /dev $target/dev
    $SUPERUSER_PERMISSION mount -t devpts chpts $target/dev/pts
    $SUPERUSER_PERMISSION mount -t tmpfs chrun $target/run
    $SUPERUSER_PERMISSION mkdir -p $target/run/lock
}

# unmount chroot
unmount_chroot() {
    [ "$1" = "-v" -o "$1" = "-vv" ] && verbose_=$1 && shift
    [ "$verbose_" ] && log_info "[i] unmount_chroot $@" >&2
    # simple deep unmount must works at most of cases ;-)
    for t in "$@"; do
        [ -d "$t" ] || continue
        t_=$(realpath "$t")
        max_=10
        while [ $max_ -gt 0 ]; do
            mounted_=$(egrep -o "\s+$t_\S*" /proc/mounts 2>/dev/null | sort -r | uniq || true)
            [ ${#mounted_} = 0 ] && break
            [ "$verbose_" = "-vv" ] && log_info "[i] umount($max_) " $mounted_ >&2
            msg_=$($SUPERUSER_PERMISSION umount -v -R $mounted_ 2>&1 || echo ERROR)
            max_=$((max_ - 1))
        done
        [ $max_ = 0 ] && {
            log_err "[e] umount_deep $@ - $msg_"
            return -1
        }
    done
    return 0
}

# $1: target path
# $2: package path
install_deb_chroot() {
    local target=$1
    local package=$2
    [ -e "$package" ] || {
        log_warn "installing $name in chroot skipped (not exist)"
        return 0
    }
    local name=$(basename $package)
    [ ! -d "$target/packages/" ] && mkdir -p "$target/packages/"
    cp -f $package $target/packages/$name
    mount_chroot "$target"
    $SUPERUSER_PERMISSION chroot $target /bin/bash -c "dpkg -i /packages/$name" || exit 1
    unmount_chroot "$target"
    rm -f $target/packages/$name
    return 0
}

# execute command in chroot
# $1: target path
# $2: command name
execute_cmd_chroot() {
    local target=$1
    local cmd=$(echo $@ | awk -F ' ' '{$1=""; print $0}')
    [ "$cmd" ] || return 1
    debug "executing '$cmd' in chroot..."
    mount_chroot "$target"
    LC_ALL=C LANG=C $SUPERUSER_PERMISSION chroot $target /bin/bash -c "$cmd"
    unmount_chroot "$target"
    return 0
}

# copy host qemu static binary to target
# $1: target arch
# $2: target path
cp_host_qemu_static() {
    local arch=$1
    local target=$2
    local isInstall=$(check_host_package qemu-user-static)
    [ -z $isInstall ] && {
        if [ "$arch" == "armhf" ]; then
            $SUPERUSER_PERMISSION cp -b /usr/bin/qemu-arm-static $target
        elif [ "$arch" == "arm64" ]; then
            $SUPERUSER_PERMISSION cp -b /usr/bin/qemu-aarch64-static $target
        fi
    }
}

# init ubuntu base env
# $1: target arch
# $2: target path
init_base_rootfs() {
    local target=$2
    cp_host_qemu_static $1 $target/usr/bin
    echo "# Ubuntu Base Rootfs Build
# Do not edit.
nameserver 8.8.8.8
">$target/etc/resolv.conf
}
# ------------------------------------------------------------------------------------------------------------------------------------------

prepare_base_rootfs() {
    local target_rootfs_path="$ROOTFS_BASE_ROOT_PATH/binary"
    [ ! -d $target_rootfs_path ] && mkdir -p $target_rootfs_path
    [ -f $_G_ROOTFS_BASE_PG_NM ] && {
        log_info "extract to $target_rootfs_path"
        extract_package "$ROOTFS_BASE_ROOT_PATH/$_G_ROOTFS_BASE_PG_NM" $target_rootfs_path
        [ $? == 0 ] && {
            log_info "$_G_ROOTFS_BASE_PG_NM extract success"
            $SUPERUSER_PERMISSION cp -b /etc/resolv.conf $target_rootfs_path/etc/resolv.conf
            if [ "$_G_ARCH" == "armhf" ]; then
                $SUPERUSER_PERMISSION cp -b /usr/bin/qemu-arm-static $target_rootfs_path/usr/bin/
            elif [ "$_G_ARCH" == "arm64" ]; then
                $SUPERUSER_PERMISSION cp -b /usr/bin/qemu-aarch64-static $target_rootfs_path/usr/bin/
            fi
        }
    }
    return 0
}

prepare_base_config_chroot() {
    local target_rootfs_path="$ROOTFS_BASE_ROOT_PATH/binary"
    mount_chroot $target_rootfs_path
    cat <<EOF | $SUPERUSER_PERMISSION chroot $target_rootfs_path
echo exit 101 > /usr/sbin/policy-rc.d
chmod +x /usr/sbin/policy-rc.d
# journal service adjustements
sed -i "s/#Storage=.*/Storage=volatile/g" /etc/systemd/journald.conf
sed -i "s/#Compress=.*/Compress=yes/g" /etc/systemd/journald.conf
sed -i "s/#RateLimitIntervalSec=.*/RateLimitIntervalSec=30s/g" /etc/systemd/journald.conf
sed -i "s/#RateLimitBurst=.*/RateLimitBurst=10000/g" /etc/systemd/journald.conf
# premit root login via SSH for the first boot
sed -i 's/#\?PermitRootLogin .*/PermitRootLogin yes/' /etc/ssh/sshd_config
# enable additional services
systemctl --no-reload enable resize2fs.service system-check.service
# disable repeated messages due to xconsole not being installed.
[[ -f /etc/rsyslog.d/50-default.conf ]] && sed '/daemon\.\*\;mail.*/,/xconsole/ s/.*/#&/' -i /etc/rsyslog.d/50-default.conf
# disable deprecated parameter
[ -f /etc/rsyslog.conf ] && sed '/.*$KLogPermitNonKernelFacility.*/,// s/.*/#&/' -i /etc/rsyslog.conf
EOF
    unmount_chroot $target_rootfs_path
}

prepare_user_config_chroot() {
    local target_rootfs_path="$ROOTFS_BASE_ROOT_PATH/binary"
    mount_chroot $target_rootfs_path
    cat <<EOF | $SUPERUSER_PERMISSION chroot $target_rootfs_path
export LC_ALL=C
export LANG=C
# default VARS
DEFAULT_USER_NAME=haos
DEFAULT_USER_PASSWORD=haos@1234
DEFAULT_ROOT_PASSWORD=haos@1234
DEFAULT_SHELL=/bin/bash
DEFAULT_GROUPS="audio,video,disk,input,tty,root,users,games,dialout,cdrom,dip,plugdev,bluetooth,pulse-access,systemd-journal,netdev,staff,i2c"
[ "$USER_NAME" ] || USER_NAME=$DEFAULT_USER_NAME
[ "$ROOT_PASSWORD" = "-" ] && ROOT_PASSWORD=$DEFAULT_USER_PASSWORD
[ "$USER_PASSWORD" = "-" ] && USER_PASSWORD=$DEFAULT_ROOT_PASSWORD
[ "$HOSTNAME" ] || HOSTNAME=$DEFAULT_USER_NAME
[ "$USER_SHELL" ] || USER_SHELL=$DEFAULT_SHELL
# setup password for root
if [ "$ROOT_PASSWORD" ]; then
    ROOT_PASSW=${ROOT_PASSWORD//?/\*}
    echo root:$ROOT_PASSWORD | chpasswd
else
    ROOT_PASSW="__EMPTY__"
    passwd -d root
fi
# setup password for user
if [ "$USER_PASSWORD" ]; then
    # openssl help passwd # read more about this
    USER_PASSWORD_ENCRYPTED=$(echo -n "$USER_PASSWORD" | openssl passwd -5 -stdin)
    useradd -m -p "$USER_PASSWORD_ENCRYPTED" -s $USER_SHELL $USER_NAME
    USER_PASSW=${USER_PASSWORD//?/\*}
else
    useradd -m -s $USER_SHELL $USER_NAME
    USER_PASSW="__EMPTY__"
    passwd -d $USER_NAME
fi
# config secure tty
for tty in ${_G_SECURE_TTY_LIST[@]}; do
    echo $tty >>/etc/securetty
done
# user mod config
usermod -aG sudo,adm $USER_NAME
# add group
IFS=','
for group in $DEFAULT_GROUPS; do
    /bin/egrep  -i "^$group" /etc/group > /dev/null
    if [ $? -ne 0 ]; then
        echo "Group '$group' does not exists in /etc/group, creating"
        groupadd $group
    fi
done
unset IFS
usermod -a -G $DEFAULT_GROUPS $USER_NAME
# set hostname
echo $HOSTNAME >/etc/hostname
# add hostname to hosts
echo "127.0.0.1   localhost $HOSTNAME" >/etc/hosts
echo "::1         localhost $HOSTNAME ip6-localhost ip6-loopback" >>/etc/hosts
echo "fe00::0     ip6-localnet" >>/etc/hosts
echo "ff00::0     ip6-mcastprefix" >>/etc/hosts
echo "ff02::1     ip6-allnodes" >>/etc/hosts
echo "ff02::2     ip6-allrouters" >>/etc/hosts
EOF
    unmount_chroot $target_rootfs_path
}

prepare_overlay_process() {
    log_info "copy overlay to rootfs"
    local target_rootfs_path="$ROOTFS_BASE_ROOT_PATH/binary"
    local rootfs_root_path=$ROOTFS_BASE_ROOT_PATH
    mkdir -p $target_rootfs_path/packages
    cp -rf $rootfs_root_path/packages/$_G_ARCH/* $target_rootfs_path/packages
    # some configs
    cp -rf $rootfs_root_path/overlay/etc $target_rootfs_path/
    cp -rf $rootfs_root_path/overlay/lib $target_rootfs_path/usr/
    cp -rf $rootfs_root_path/overlay/usr $target_rootfs_path/
    if [ "$ARCH" == "armhf" ]; then
        cp $rootfs_root_path/overlay-firmware/usr/bin/brcm_patchram_plus1_32 $target_rootfs_path/usr/bin/brcm_patchram_plus1
        cp $rootfs_root_path/overlay-firmware/usr/bin/rk_wifi_init_32 $target_rootfs_path/usr/bin/rk_wifi_init
    elif [ "$ARCH" == "arm64" ]; then
        cp $rootfs_root_path/overlay-firmware/usr/bin/brcm_patchram_plus1_64 $target_rootfs_path/usr/bin/brcm_patchram_plus1
        cp $rootfs_root_path/overlay-firmware/usr/bin/rk_wifi_init_64 $target_rootfs_path/usr/bin/rk_wifi_init
    fi
    # bt,wifi,audio firmware
    mkdir -p $target_rootfs_path/system/lib/modules/
    find $CODE_PATH/kernel/drivers/net/wireless/rockchip_wlan/* -name "*.ko" |
        xargs -n1 -i sudo cp {} $target_rootfs_path/system/lib/modules/
    cp -rf $rootfs_root_path/overlay-firmware/etc $target_rootfs_path/
    cp -rf $rootfs_root_path/overlay-firmware/lib $target_rootfs_path/usr/
    cp -rf $rootfs_root_path/overlay-firmware/usr $target_rootfs_path/
    # adb
    if [ "$_G_ROOTFS_DEBUG_TAG" == "debug" ]; then
        if [ "$ARCH" == "armhf" ]; then
            cp -rf $rootfs_root_path/overlay-debug/usr/local/share/adb/adbd-32 $target_rootfs_path/usr/local/bin/adbd
        elif [ "$ARCH" == "arm64" ]; then
            cp -rf $rootfs_root_path/overlay-debug/usr/local/share/adb/adbd-64 $target_rootfs_path/usr/local/bin/adbd
        fi
    fi
    if [ "$_G_ROOTFS_DEBUG_TAG" == "debug" ] || [ "$_G_ROOTFS_DEBUG_TAG" == "jenkins" ]; then
        # adb, video, camera  test file
        cp -rf $rootfs_root_path/overlay-debug/etc $target_rootfs_path/
        cp -rf $rootfs_root_path/overlay-debug/lib $target_rootfs_path/usr/
        cp -rf $rootfs_root_path/overlay-debug/usr $target_rootfs_path/
    fi
    if [ "$VERSION" == "jenkins" ]; then
        # network
        cp -b /etc/resolv.conf $target_rootfs_path/etc/resolv.conf
    fi
}

install_base_deb() {
    local target_rootfs_path="$ROOTFS_BASE_ROOT_PATH/binary"
    mount_chroot $target_rootfs_path
    cat <<EOF | $SUPERUSER_PERMISSION chroot $target_rootfs_path
echo exit 101 > /usr/sbin/policy-rc.d
chmod +x /usr/sbin/policy-rc.d
# journal service adjustements
sed -i "s/#Storage=.*/Storage=volatile/g" /etc/systemd/journald.conf
sed -i "s/#Compress=.*/Compress=yes/g" /etc/systemd/journald.conf
sed -i "s/#RateLimitIntervalSec=.*/RateLimitIntervalSec=30s/g" /etc/systemd/journald.conf
sed -i "s/#RateLimitBurst=.*/RateLimitBurst=10000/g" /etc/systemd/journald.conf
EOF
    unmount_chroot $target_rootfs_path
}

install_user_deb() {
    local target_rootfs_path="$ROOTFS_BASE_ROOT_PATH/binary"
    mount_chroot $target_rootfs_path
    cat <<EOF | $SUPERUSER_PERMISSION chroot $target_rootfs_path
# +++++++++++++++++++++++++++++++++++++++ packages process +++++++++++++++++++++++++++++++++++++++
echo -e "\033[36m Install ffmpeg \033[0m"
\${APT_INSTALL_CMD} ffmpeg
dpkg -i  /packages/ffmpeg/*.deb
\${APT_INSTALL_CMD}
echo -e "\033[36m Install libdrm \033[0m"
dpkg -i  /packages/libdrm/*.deb
apt-get install -f -y
echo -e "\033[36m Install power management \033[0m"
\${APT_INSTALL_CMD} busybox pm-utils triggerhappy
cp /etc/Powermanager/triggerhappy.service  /lib/systemd/system/triggerhappy.service
# +++++++++++++++++++++++++++++++++++++++ user process +++++++++++++++++++++++++++++++++++++++++++
if [ "$_G_ROOTFS_TARGET_TYPE" == "server" ]; then
    \${APT_INSTALL_CMD} rsyslog sudo dialog apt-utils ntp evtest
fi
EOF
    unmount_chroot $target_rootfs_path
}

install_bsp_deb() {
    # Install linux image deb in chroot
    if [ -f $BUILD_DEBS/$VERSION/$KHADAS_BOARD/${LINUX_IMAGE_DEB}_${VERSION}_${DISTRIB_ARCH}.deb ]; then
        install_deb_chroot $BUILD_DEBS/$VERSION/$KHADAS_BOARD/${LINUX_IMAGE_DEB}_${VERSION}_${DISTRIB_ARCH}.deb
    fi
    # Install linux dtb deb in chroot
    if [ -f $BUILD_DEBS/$VERSION/$KHADAS_BOARD/${LINUX_IMAGE_DEB/image/dtb}_${VERSION}_${DISTRIB_ARCH}.deb ]; then
        install_deb_chroot $BUILD_DEBS/$VERSION/$KHADAS_BOARD/${LINUX_IMAGE_DEB/image/dtb}_${VERSION}_${DISTRIB_ARCH}.deb
    fi
    # Install linux headers deb in chroot
    if [ "$SKIP_HEADER_DEB" != "yes" ]; then
        if [ -f $BUILD_DEBS/$VERSION/$KHADAS_BOARD/${LINUX_IMAGE_DEB/image/headers}_${VERSION}_${DISTRIB_ARCH}.deb ]; then
            install_deb_chroot $BUILD_DEBS/$VERSION/$KHADAS_BOARD/${LINUX_IMAGE_DEB/image/headers}_${VERSION}_${DISTRIB_ARCH}.deb
        fi
    else
        warning_msg "Skip install header package ..."
    fi
    # Install linux firmware in chroot
    if [ -f $BUILD_DEBS/$VERSION/$KHADAS_BOARD/${LINUX_FIRMWARE_DEB}_${VERSION}_${DISTRIB_ARCH}.deb ]; then
        install_deb_chroot $BUILD_DEBS/$VERSION/$KHADAS_BOARD/${LINUX_FIRMWARE_DEB}_${VERSION}_${DISTRIB_ARCH}.deb
    fi
    # Install u-boot deb in chroot
    if [ -f $BUILD_DEBS/$VERSION/$KHADAS_BOARD/${LINUX_UBOOT_DEB}_${VERSION}-${UBOOT_VER}_${DISTRIB_ARCH}.deb ]; then
        install_deb_chroot $BUILD_DEBS/$VERSION/$KHADAS_BOARD/${LINUX_UBOOT_DEB}_${VERSION}-${UBOOT_VER}_${DISTRIB_ARCH}.deb
    fi
    if [ -n "$GPU_VER" ]; then
        # Install GPU deb in chroot
        if [ -f $BUILD_DEBS/$VERSION/$KHADAS_BOARD/linux-gpu-mali-${GPU_PLATFORM}_${VERSION}-${GPU_VER}_${DISTRIB_ARCH}.deb ]; then
            install_deb_chroot $BUILD_DEBS/$VERSION/$KHADAS_BOARD/linux-gpu-mali-${GPU_PLATFORM}_${VERSION}-${GPU_VER}_${DISTRIB_ARCH}.deb
        fi
        # Install GPU development deb in chroot
        if [ -f $BUILD_DEBS/$VERSION/$KHADAS_BOARD/linux-gpu-${VENDOR,,}-dev_${VERSION}_${DISTRIB_ARCH}.deb ]; then
            install_deb_chroot $BUILD_DEBS/$VERSION/$KHADAS_BOARD/linux-gpu-${VENDOR,,}-dev_${VERSION}_${DISTRIB_ARCH}.deb
        fi
    fi
    # Install common deb packages
    if [[ $(type -t install_common_deb) == function ]]; then
        install_common_deb
    fi
    # Install packages platform
    if [[ $(type -t install_deb_packages_platform) == function ]]; then
        install_deb_packages_platform
    fi
    # Install board deb in chroot
    install_deb_chroot $BUILD_DEBS/$VERSION/$KHADAS_BOARD/${DISTRIBUTION}-${DISTRIB_RELEASE}/${LINUX_BOARD_DEB}_${VERSION}_${DISTRIB_ARCH}.deb
    if [ "$DISTRIB_TYPE" != "minimal" ]; then
        # Install updater deb in chroot
        install_deb_chroot $BUILD_DEBS/$VERSION/$KHADAS_BOARD/${DISTRIBUTION}-${DISTRIB_RELEASE}/${FENIX_UPDATER_DEB}_${VERSION}_${DISTRIB_ARCH}.deb
    fi
}

windup_process() {
    local target_rootfs_path="$ROOTFS_BASE_ROOT_PATH/binary"
    mount_chroot $target_rootfs_path
    cat <<EOF | $SUPERUSER_PERMISSION chroot $target_rootfs_path
# command handle
export APT_INSTALL_CMD="apt-get install -f -y"
apt-get -y update
# +++++++++++++++++++++++++++++++++++++++ clean process ++++++++++++++++++++++++++++++++++++++++++
apt-get clean
apt-get -y autoremove
rm -rf /var/lib/apt/lists/*
EOF
    unmount_chroot $target_rootfs_path
}

build_rootfs_a() {
    prepare_overlay_process
    prepare_base_rootfs
    prepare_base_config_chroot
    prepare_user_config_chroot
    install_base_deb
    install_bsp_deb
    install_user_deb
    windup_process
}
